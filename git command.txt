git clone https://github.com/yourname/folder.git // клонирование репозитория
git diff // просмотр изменений (каждая ветка хранит дельту)
git diff <имя_ветки> // просмотр изменений по сравнению с другой веткой
git add <имя файла> // добавление файла
git add . // добавление всех изменений/файлов
git commit // сохранение изменений
git commit -am "change1" // сохранение изменений c описанием коммита - сохраненное состояние файла (-a означает добавление всех изменненных файлов в коммит, -m название коммита)
git commit --amend // изменение описания коммита
git mv <source> <destination> // перемещение файла

git status //просмотр коммитов
git log // история всех коммитов
git reset <commit_hash> // восстановление коммита (отмена изменений)
git stash // скрыть изменения без коммита
git stash -u // скрыть изменения без коммита в неотслеживаемых файлах
git stash list // показать скрытые изменения без коммита
git stash pop // вернуть скрытые изменения без коммита
git stash clear // удалить изменения навсегда
git restore <file> // восстановить файл
git checkout -- <file> // восстановить файл (старая версия git)

git branch // просмотр веток
git branch <name> // создать ветку
git branch -D // удалить ветку локально
git checkout // в какой ветке находишься
git checkout <name> или git switch // перейти в ветку
dir // просмотр файлов в Windows
git checkout - // переход на предыдущую используемую ветку
git checkout -b <имя_ветки> или git switch -c <имя_ветки>// создание ветки и переход в нее
git pull // получить последнюю версию изменений
git pull origin <имя_ветки> // получить последнюю версию изменений по ветке

git merge // слияние веток в текущую
git merge <имя_ветки> // слияние веток в текущую
git merge --abort или git reset --merge // отказаться от объединения веток - прерывает мёрдж веток и отменяет все незавершённые изменения
git merge --continue или git commit // закомитить изменения после разрешения конфликта

git difftool <имя_ветки> // сравнение изменений
git config merge.tool meld // настройка mergetool meld
git mergetool <название утилиты> // например, meld, vimdiff
git push origin <имя_ветки> // отправить на github ветку
git push origin main // отправить на github все изменения в main
atom <имя файла> // просмотр файла в текстовом редакторе для изменений

git remote или git remote get-url или git remote -v // просмотреть origin вашего репозитория (push - для отправки изменений, fetch - для получения)
git remote show origin // получить более подробную информацию о репозитории origin
git branch -m // переименовывать ветки 
git branch -d <имя_ветки> // удалять локальные ветки
git branch -D <имя_ветки> // удалять локальные ветки вне зависимости от статуса
git branch -r // доступные ветки в удаленном репозитории
git fetch origin <имя_ветки для копирования на локальную машину> + git switch <имя_ветки> // получение ветки на локальную машину и переключение на нее
git help <название команды> // помощь по команде

git checkout <название хэша коммита из git log> // переключиться на другой коммит
git clean -fd // удалить untracked файлы, директории (созданные случайно)
git checkout path/to/file // привести измененный файл в начальное состояние (до изменения)
git cherry-pick <Commit1> <Commit2> <...> // копировать несколько коммитов на место, где сейчас находишься (HEAD)
git rebase -i HEAD~4 // интерактивная перестановка коммитов, pick - убрать коммит
git tag v1 C1 // добавление тега
git describe <ref> // показывает, как далеко текущее состояние от ближайшего тега с форматом ответа <tag>_<numCommits>_g<hash>
// tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.

// Внести изменения в более ранний коммит:
1. Переставить коммит так, чтобы нужный находился наверху при помощи git rebase -i
2. Внести изменения при помощи git commit --amend
3. Переставить всё обратно при помощи git rebase -i
4. И наконец, переместить main на изменённую часть дерева, чтобы закончить уровень.

КЛИЕНТСКИЕ ХУКИ
pre-push 
В процессе пуша изменений, но непосредственно перед отправкой.
Может позволить проверить некоторые исторические данные, чтобы попросить пользователя обновить репозиторий.

pre-rebase
Перед ребейзом.
Запрет на ребейз, если у вас есть неотправленные изменения.

pre-commit
Сразу после того как вы набрали git commit, ещё до того, как вы начали набирать описание коммита.
Проверка стиля кода. Проверка наличия документации.

prepare-commit-msg
После pre-commit, перед открытием текстового редактора.
Автоматическая подстановка какого-то значения в описание коммита.

commit-msg
После того, как вы ввели описание коммита и закрыли редактор.
Проверка сообщения в коммите на соответствие шаблону.

post-rewrite
После изменения описания коммита.
Подготовка переменных окружения.

post-checkout
Сразу после git checkout.
Подготовка переменных окружения.

post-merge
После успешного мёрджа изменений.
Восстановление некоторых данных, которые Git не хранит.

post-commit
После завершения коммита.
Отправка сообщения (системный попап) с текстом «коммит завершён».

СЕРВЕРНЫЕ ХУКИ
pre-receive
Прямо перед получением изменений на сервер.
Проверка прав на запись в данный репозиторий/папки/файлы.

update
Аналогично pre-receive, но проверяется для каждой ветки, которую вы отправляете.
Проверка прав доступа.

post-receive
После получения изменений.
Обновление кода на сервере, уведомление других пользователей.
